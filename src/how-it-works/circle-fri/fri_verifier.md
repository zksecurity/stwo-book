# FRI Verifier


In this section, we describe the implementation of the FRI verifier in Stwo, continuing the example from the technical overview and prover documentation. The verifier's role is to check that all folding steps have been performed correctly by the prover.

The `FriVerifier` struct verifies the FRI proof generated by the prover.
```rust,no_run,noplayground
{{#webinclude https://raw.githubusercontent.com/starkware-libs/stwo/0790eba46b8af5697083d84fb75bd34b08a0b31f/crates/stwo/src/core/fri.rs 84:97}}
```

The main components are:

- **config**: The `FriConfig` containing protocol parameters.
- **first_layer**: The first layer verifier, which checks Merkle decommitments for all initial circle polynomials (i.e., $h_0$, $h_1$, $h_2$).
- **inner_layers**: A vector of inner layer verifiers, each corresponding to a folding round and its Merkle decommitment (i.e., two layers, corresponding to $g_0$ and $g_1$).
- **last_layer_domain**: The "line" domain for the final layer polynomial (i.e., $I_2$).
- **last_layer_poly**: The final "line" polynomial $g_2$ sent in clear by the prover.
- **queries**: The set of queries used for spot-checking the folding identities.

## Initialization


The `commit` function initializes the `FriVerifier` using the FRI proof, the Fiat-Shamir channel, and protocol parameters. It sets up the verifier for the query phase.

```rust,no_run,noplayground
{{#webinclude https://raw.githubusercontent.com/starkware-libs/stwo/0790eba46b8af5697083d84fb75bd34b08a0b31f/crates/stwo/src/core/fri.rs 116:186}}
```


The inputs are as follows:
- `channel`: The Fiat-Shamir channel for randomness and transcript hashing.
- `config`: The `FriConfig` with protocol parameters.
- `proof`: The `FriProof` struct containing Merkle decommitments and the last layer polynomial.
- `column_bounds`: The degree bounds for each committed circle polynomial, in descending order.



At a high level, it proceeds as follows:
1. Initializes the first layer verifier with the Merkle decommitments for circle polynomials $h_0$, $h_1$, $h_2$, their respective domains $H_0$, $H_1$, $H_2$, their degree bounds, and folding randomness $\lambda_0$.
2. Initializes each inner layer verifier with its Merkle decommitment, domain, degree bounds, and folding randomness. For our example:
    - The first inner FRI verifier layer will store decommitments for $g_0$, its domain $I_0$, degree bound, and folding randomness $\lambda_1$.
    - Similarly, the second inner FRI verifier layer will store decommitments for $g_1$, its domain $I_1$, degree bound, and folding randomness $\lambda_2$.
3. Stores the last layer polynomial $g_2$ and its domain $I_2$.
4. Initializes the `queries` as `None` and prepares the verifier for the query phase.
5. Outputs the `FriVerifier` struct.

## Query generation


The function `sample_query_positions` uses the Fiat-Shamir channel to generate random query positions for checking the folding equations. It maps each domain size to its respective query positions, ensuring that queries are adapted to the domain of each polynomial.

```rust,no_run,noplayground
{{#webinclude https://raw.githubusercontent.com/starkware-libs/stwo/0790eba46b8af5697083d84fb75bd34b08a0b31f/crates/stwo/src/core/fri.rs 306:320}}
```


It takes the following input:
- `&mut self`: This will be used to update the `queries` in `FriVerifier`, which was initialized to `None`.
- `channel`: The Fiat-Shamir channel.


At a high level, it proceeds as follows:
1. Samples `n_queries` random positions on the largest domain using the `channel`.
2. Returns a mapping from domain log sizes to their respective query positions using the function `query_positions_by_log_size`.


Suppose $s=1$ query is sampled at $P_0 = (x_0, y_0) \in H_0$. The function computes the corresponding positions $P_1 = \pi(P_0)$ in $H_1$ and $P_2 = \pi(P_1)$ in $H_2$, mapping each to the correct domain size.

## Verification


The function `decommit` verifies the `FriVerifier` after it has been initialized with the `FriProof` by verifying the Merkle decommitments and folding equations for all layers. It ensures that the prover's folding steps were performed correctly and that the final polynomial is close to the expected polynomial space.

```rust,no_run,noplayground
{{#webinclude https://raw.githubusercontent.com/starkware-libs/stwo/0790eba46b8af5697083d84fb75bd34b08a0b31f/crates/stwo/src/core/fri.rs 199:218}}
```


It takes the following as input:
- `mut self`: The `FriVerifier` struct after initialization using the `commit` function.
- `first_layer_query_evals`: The evaluations of the circle polynomials at the sampled query points.

It proceeds as follows:
1. **First Layer Verification:**
    - Verifies Merkle decommitments for $h_0$, $h_1$, $h_2$ at the queried points $P_0$, $P_1$, and $P_2$, respectively.
    - Extracts the necessary evaluations for folding into the next layer.
2. **Inner Layer Verification:**
    - For each inner layer, verifies Merkle decommitments for $g_0$, $g_1$ at the folded query points $x_0$ and $x_1$, respectively.
    - Checks the following two folding equations using the folding randomness and the evaluations from previous layers.
    $$
    \begin{aligned}
        g_0(x_0) &= 
        \lambda_0^2 \cdot 
        \left(
        \frac{h_0(x_0,y_0) + h_0(x_0,-y_0)}{2}
        + \lambda_0 \cdot 
        \frac{h_0(x_0,y_0) - h_0(x_0,-y_0)}{2 \cdot y_0}
        \right)
    \end{aligned}
    $$
    $$
    \begin{aligned}
        g_1(x_1) &= 
        \frac{g_{0}(x_{0}) + g_{0}(-x_{0})}{2}
        + \lambda_1 \cdot 
        \frac{g_{0}(x_{0}) - g_{0}(-x_{0})}{2 \cdot x_{0}} \\
        &\quad + \lambda_1^2 \cdot 
        \left(
        \frac{h_1(x_1,y_1) + h_1(x_1,-y_1)}{2}
        + \lambda_1 \cdot 
        \frac{h_1(x_1,y_1) - h_1(x_1,-y_1)}{2 \cdot y_1}
        \right)
    \end{aligned}
    $$
    where $P_0 = (x_0, y_0)$ and $P_1 = \pi((x_0, y_0)) = (x_1, y_1)$.

3. **Last Layer Verification:**
    - Checks that the final polynomial $g_2$ matches the evaluations at the last layer's query positions.
4. Returns success if all checks pass; otherwise, returns an error indicating which layer failed.